/**
 * Service RAG (Retrieval-Augmented Generation) int√©gr√©
 * G√©n√©ration de r√©ponses enrichies bas√©es sur la r√©cup√©ration de donn√©es
 */

const ConversationMemory = require('./conversationMemory');
const Enterprise = require('../models/Entreprise');
const KPI = require('../models/KPI');
const Report = require('../models/Report');
const User = require('../models/User');
const NodeCache = require('node-cache');

class RAGService {
    constructor() {
        this.conversationMemory = new ConversationMemory();
        this.responseCache = new NodeCache({ 
            stdTTL: 600, // 10 minutes
            checkperiod: 120
        });
        
        this.isInitialized = false;
        this.retrievalStrategies = {
            semantic: 'embedding_based',
            keyword: 'rule_based',
            hybrid: 'combined',
            contextual: 'conversation_aware'
        };
        
        this.generationStrategies = {
            template: 'template_based',
            dynamic: 'dynamic_generation',
            contextual: 'context_aware',
            personalized: 'user_specific'
        };
    }

    /**
     * Initialisation du service RAG
     */
    async initialize() {
        if (this.isInitialized) return;

        try {
            console.log('üîÑ Initialisation du service RAG...');
            
            await this.conversationMemory.initialize();
            
            this.isInitialized = true;
            console.log('‚úÖ Service RAG initialis√©');
        } catch (error) {
            console.error('‚ùå Erreur initialisation RAG:', error);
            this.isInitialized = true; // Continuer avec fonctionnalit√©s limit√©es
        }
    }

    /**
     * G√©n√©ration de r√©ponse RAG compl√®te
     */
    async generateRAGResponse(question, userRole, enterpriseId, userId, sessionId) {
        if (!this.isInitialized) await this.initialize();

        const startTime = Date.now();
        
        try {
            // 1. Analyse de la question
            const questionAnalysis = await this.analyzeQuestion(question, userRole);
            
            // 2. R√©cup√©ration de donn√©es contextuelles
            const retrievedData = await this.retrieveRelevantData(
                questionAnalysis,
                userRole,
                enterpriseId,
                userId
            );
            
            // 3. G√©n√©ration de la r√©ponse enrichie
            const generatedResponse = await this.generateEnrichedResponse(
                question,
                questionAnalysis,
                retrievedData,
                userRole,
                enterpriseId,
                userId
            );
            
            // 4. Enrichissement avec le contexte conversationnel
            const contextualResponse = await this.addConversationalContext(
                generatedResponse,
                sessionId,
                userId
            );
            
            // 5. Personnalisation finale
            const personalizedResponse = await this.personalizeResponse(
                contextualResponse,
                userId,
                userRole
            );
            
            const responseTime = Date.now() - startTime;
            
            return {
                success: true,
                question: question,
                answer: personalizedResponse.content,
                approach: 'rag',
                confidence: personalizedResponse.confidence,
                responseTime: responseTime,
                metadata: {
                    questionAnalysis,
                    retrievedData: {
                        sources: retrievedData.sources.length,
                        dataTypes: retrievedData.dataTypes,
                        relevance: retrievedData.averageRelevance
                    },
                    generationStrategy: personalizedResponse.strategy,
                    personalizationLevel: personalizedResponse.personalizationLevel,
                    sessionId,
                    userId,
                    timestamp: new Date()
                },
                suggestions: await this.generateContextualSuggestions(
                    questionAnalysis,
                    retrievedData,
                    userRole,
                    enterpriseId
                )
            };
            
        } catch (error) {
            console.error('Erreur g√©n√©ration RAG:', error);
            return {
                success: false,
                error: 'Erreur lors de la g√©n√©ration de la r√©ponse',
                approach: 'error',
                confidence: 0,
                responseTime: Date.now() - startTime
            };
        }
    }

    /**
     * Analyse de la question
     */
    async analyzeQuestion(question, userRole) {
        const analysis = {
            intent: this.extractIntent(question),
            entities: this.extractEntities(question),
            category: this.categorizeQuestion(question, userRole),
            complexity: this.assessComplexity(question),
            keywords: this.extractKeywords(question),
            context: this.extractContext(question),
            userRole,
            timestamp: new Date()
        };

        return analysis;
    }

    /**
     * Extraction de l'intention
     */
    extractIntent(question) {
        const questionLower = question.toLowerCase();
        
        const intentPatterns = {
            'information': ['comment', 'quoi', 'qu\'est-ce', 'explique', 'd√©finis'],
            'action': ['cr√©er', 'modifier', 'supprimer', 'ajouter', 'g√©n√©rer'],
            'analysis': ['analyse', 'statistiques', 'rapport', 'performance', 'tendance'],
            'help': ['aide', 'help', 'assistance', 'support'],
            'comparison': ['comparer', 'diff√©rence', 'vs', 'contre'],
            'status': ['√©tat', 'statut', 'situation', 'o√π en suis-je']
        };

        for (const [intent, patterns] of Object.entries(intentPatterns)) {
            if (patterns.some(pattern => questionLower.includes(pattern))) {
                return intent;
            }
        }

        return 'general';
    }

    /**
     * Extraction des entit√©s
     */
    extractEntities(question) {
        const entities = {
            kpis: [],
            reports: [],
            users: [],
            enterprises: [],
            dates: [],
            numbers: []
        };

        // Extraction des KPIs
        const kpiPatterns = ['kpi', 'indicateur', 'm√©trique', 'performance'];
        kpiPatterns.forEach(pattern => {
            if (question.toLowerCase().includes(pattern)) {
                entities.kpis.push(pattern);
            }
        });

        // Extraction des rapports
        const reportPatterns = ['rapport', 'rapports', 'report', 'bilan'];
        reportPatterns.forEach(pattern => {
            if (question.toLowerCase().includes(pattern)) {
                entities.reports.push(pattern);
            }
        });

        // Extraction des nombres
        const numberMatches = question.match(/\d+/g);
        if (numberMatches) {
            entities.numbers = numberMatches.map(n => parseInt(n));
        }

        return entities;
    }

    /**
     * Cat√©gorisation de la question
     */
    categorizeQuestion(question, userRole) {
        const questionLower = question.toLowerCase();
        
        const categories = {
            'admin': {
                'users': ['utilisateur', 'compte', 'gestion', 'cr√©er utilisateur'],
                'system': ['syst√®me', 'configuration', 'param√®tre', 'r√©glage'],
                'analytics': ['statistique', 'global', 'toutes les entreprises'],
                'security': ['s√©curit√©', 'permission', 'acc√®s', 'r√¥le']
            },
            'enterprise': {
                'kpis': ['kpi', 'indicateur', 'performance', 'm√©trique'],
                'reports': ['rapport', 'bilan', 'r√©sum√©', 'export'],
                'data': ['donn√©e', 'information', 'historique', 'archive'],
                'improvement': ['am√©liorer', 'optimiser', 'conseil', 'recommandation']
            }
        };

        const roleCategories = categories[userRole] || {};
        
        for (const [category, keywords] of Object.entries(roleCategories)) {
            if (keywords.some(keyword => questionLower.includes(keyword))) {
                return category;
            }
        }

        return 'general';
    }

    /**
     * R√©cup√©ration de donn√©es pertinentes
     */
    async retrieveRelevantData(questionAnalysis, userRole, enterpriseId, userId) {
        const retrievedData = {
            sources: [],
            dataTypes: [],
            averageRelevance: 0,
            enterpriseData: null,
            userData: null,
            historicalData: null,
            contextualData: null
        };

        try {
            // R√©cup√©ration des donn√©es d'entreprise
            if (enterpriseId) {
                retrievedData.enterpriseData = await this.retrieveEnterpriseData(
                    enterpriseId,
                    questionAnalysis
                );
                retrievedData.sources.push('enterprise');
            }

            // R√©cup√©ration des donn√©es utilisateur
            if (userId) {
                retrievedData.userData = await this.retrieveUserData(
                    userId,
                    questionAnalysis
                );
                retrievedData.sources.push('user');
            }

            // R√©cup√©ration des donn√©es historiques
            retrievedData.historicalData = await this.retrieveHistoricalData(
                questionAnalysis,
                userRole,
                enterpriseId
            );
            retrievedData.sources.push('historical');

            // R√©cup√©ration du contexte conversationnel
            retrievedData.contextualData = await this.retrieveConversationalContext(
                userId,
                questionAnalysis
            );
            retrievedData.sources.push('contextual');

            // Calcul de la pertinence moyenne
            retrievedData.averageRelevance = this.calculateAverageRelevance(retrievedData);

            return retrievedData;

        } catch (error) {
            console.error('Erreur r√©cup√©ration donn√©es:', error);
            return retrievedData;
        }
    }

    /**
     * R√©cup√©ration des donn√©es d'entreprise
     */
    async retrieveEnterpriseData(enterpriseId, questionAnalysis) {
        try {
            const enterprise = await Enterprise.findById(enterpriseId);
            if (!enterprise) return null;

            const data = {
                basicInfo: {
                    name: enterprise.nom,
                    sector: enterprise.secteur,
                    size: enterprise.taille,
                    status: enterprise.statut
                },
                kpis: [],
                reports: [],
                performance: null
            };

            // R√©cup√©ration des KPIs
            if (questionAnalysis.entities.kpis.length > 0) {
                data.kpis = await KPI.find({ entrepriseId })
                    .sort({ createdAt: -1 })
                    .limit(10);
            }

            // R√©cup√©ration des rapports
            if (questionAnalysis.entities.reports.length > 0) {
                data.reports = await Report.find({ entrepriseId })
                    .sort({ createdAt: -1 })
                    .limit(5);
            }

            // Calcul des performances
            if (questionAnalysis.intent === 'analysis') {
                data.performance = await this.calculateEnterprisePerformance(enterpriseId);
            }

            return data;

        } catch (error) {
            console.error('Erreur r√©cup√©ration donn√©es entreprise:', error);
            return null;
        }
    }

    /**
     * R√©cup√©ration des donn√©es utilisateur
     */
    async retrieveUserData(userId, questionAnalysis) {
        try {
            const user = await User.findById(userId);
            if (!user) return null;

            return {
                profile: {
                    name: user.nom,
                    email: user.email,
                    role: user.typeCompte,
                    enterpriseId: user.entrepriseId,
                    lastLogin: user.lastLogin
                },
                preferences: await this.conversationMemory.getUserPreferences(userId),
                history: await this.conversationMemory.getUserHistory(userId, 5),
                patterns: this.extractUserPatterns(userId)
            };

        } catch (error) {
            console.error('Erreur r√©cup√©ration donn√©es utilisateur:', error);
            return null;
        }
    }

    /**
     * R√©cup√©ration des donn√©es historiques
     */
    async retrieveHistoricalData(questionAnalysis, userRole, enterpriseId) {
        try {
            const historicalData = {
                trends: [],
                patterns: [],
                benchmarks: [],
                insights: []
            };

            // Analyse des tendances
            if (questionAnalysis.intent === 'analysis') {
                historicalData.trends = await this.analyzeTrends(userRole, enterpriseId);
            }

            // Patterns d'utilisation
            if (questionAnalysis.intent === 'help') {
                historicalData.patterns = await this.analyzeUsagePatterns(userRole);
            }

            // Benchmarks sectoriels
            if (enterpriseId && questionAnalysis.category === 'kpis') {
                historicalData.benchmarks = await this.getSectorBenchmarks(enterpriseId);
            }

            return historicalData;

        } catch (error) {
            console.error('Erreur r√©cup√©ration donn√©es historiques:', error);
            return null;
        }
    }

    /**
     * G√©n√©ration de r√©ponse enrichie
     */
    async generateEnrichedResponse(question, questionAnalysis, retrievedData, userRole, enterpriseId, userId) {
        const response = {
            content: '',
            confidence: 0,
            strategy: 'template',
            personalizationLevel: 'basic',
            components: []
        };

        try {
            // G√©n√©ration bas√©e sur l'intention
            switch (questionAnalysis.intent) {
                case 'information':
                    response.content = await this.generateInformationalResponse(
                        question,
                        questionAnalysis,
                        retrievedData
                    );
                    response.strategy = 'template';
                    break;

                case 'analysis':
                    response.content = await this.generateAnalyticalResponse(
                        question,
                        questionAnalysis,
                        retrievedData
                    );
                    response.strategy = 'dynamic';
                    break;

                case 'action':
                    response.content = await this.generateActionResponse(
                        question,
                        questionAnalysis,
                        retrievedData
                    );
                    response.strategy = 'contextual';
                    break;

                default:
                    response.content = await this.generateGeneralResponse(
                        question,
                        questionAnalysis,
                        retrievedData
                    );
                    response.strategy = 'template';
            }

            // Calcul de la confiance
            response.confidence = this.calculateResponseConfidence(
                questionAnalysis,
                retrievedData,
                response.content
            );

            // Niveau de personnalisation
            response.personalizationLevel = this.assessPersonalizationLevel(
                retrievedData,
                userId
            );

            return response;

        } catch (error) {
            console.error('Erreur g√©n√©ration r√©ponse:', error);
            return {
                content: 'Je ne peux pas g√©n√©rer de r√©ponse enrichie pour le moment.',
                confidence: 0.3,
                strategy: 'fallback',
                personalizationLevel: 'none'
            };
        }
    }

    /**
     * G√©n√©ration de r√©ponse informationnelle
     */
    async generateInformationalResponse(question, questionAnalysis, retrievedData) {
        let response = '';

        // R√©ponse bas√©e sur les donn√©es d'entreprise
        if (retrievedData.enterpriseData) {
            const enterprise = retrievedData.enterpriseData.basicInfo;
            response += `Pour votre entreprise **${enterprise.name}** (secteur: ${enterprise.sector}), `;
        }

        // R√©ponse bas√©e sur la cat√©gorie
        switch (questionAnalysis.category) {
            case 'kpis':
                response += this.generateKPIInformation(retrievedData);
                break;
            case 'reports':
                response += this.generateReportInformation(retrievedData);
                break;
            case 'users':
                response += this.generateUserInformation(retrievedData);
                break;
            default:
                response += this.generateGeneralInformation(questionAnalysis);
        }

        return response;
    }

    /**
     * G√©n√©ration de r√©ponse analytique
     */
    async generateAnalyticalResponse(question, questionAnalysis, retrievedData) {
        let response = '## Analyse des donn√©es\n\n';

        if (retrievedData.enterpriseData?.performance) {
            const performance = retrievedData.enterpriseData.performance;
            response += `### Performance actuelle\n`;
            response += `- **Score global**: ${performance.overallScore}/100\n`;
            response += `- **Tendance**: ${performance.trend}\n`;
            response += `- **Points forts**: ${performance.strengths.join(', ')}\n`;
            response += `- **Axes d'am√©lioration**: ${performance.improvements.join(', ')}\n\n`;
        }

        if (retrievedData.historicalData?.trends) {
            response += `### Tendances observ√©es\n`;
            retrievedData.historicalData.trends.forEach(trend => {
                response += `- ${trend.description}\n`;
            });
        }

        return response;
    }

    /**
     * G√©n√©ration de suggestions contextuelles
     */
    async generateContextualSuggestions(questionAnalysis, retrievedData, userRole, enterpriseId) {
        const suggestions = [];

        // Suggestions bas√©es sur l'intention
        switch (questionAnalysis.intent) {
            case 'analysis':
                suggestions.push('Affiche-moi les d√©tails');
                suggestions.push('Compare avec le mois dernier');
                suggestions.push('G√©n√®re un rapport complet');
                break;

            case 'action':
                suggestions.push('Guide-moi √©tape par √©tape');
                suggestions.push('Montre-moi un exemple');
                suggestions.push('Quels sont les pr√©requis ?');
                break;

            case 'information':
                suggestions.push('Peux-tu expliquer plus en d√©tail ?');
                suggestions.push('Quels sont les avantages ?');
                suggestions.push('Y a-t-il des alternatives ?');
                break;
        }

        // Suggestions bas√©es sur les donn√©es r√©cup√©r√©es
        if (retrievedData.enterpriseData?.kpis?.length > 0) {
            suggestions.push('Analyse mes KPIs les plus r√©cents');
        }

        if (retrievedData.historicalData?.trends?.length > 0) {
            suggestions.push('Montre-moi l\'√©volution sur 6 mois');
        }

        return suggestions.slice(0, 4);
    }

    /**
     * Statistiques du service RAG
     */
    getStats() {
        return {
            isInitialized: this.isInitialized,
            cacheStats: this.responseCache.getStats(),
            memoryStats: this.conversationMemory.getStats(),
            retrievalStrategies: Object.keys(this.retrievalStrategies),
            generationStrategies: Object.keys(this.generationStrategies)
        };
    }

    /**
     * Nettoyage des ressources
     */
    async destroy() {
        this.responseCache.destroy();
        await this.conversationMemory.destroy();
        this.isInitialized = false;
    }
}

module.exports = RAGService;



